# Python API for managing customers and their favorite products

A Python implementation of an API for managing customers and their respective lists of favorite products, using an external API for product data and a PostgreSQL database.
Author: Leonardo Pahim

## API Structure and How It Works

Each customer has a name, a unique email, and a list of favorite products. The products used come from the external FakeStoreAPI.com and are referenced in the project by their numeric ID. (It's worth noting that FakeStoreAPI only has 20 products).

The administrator must generate an access token through the /api/v1/auth/master-token endpoint with their username and password. The other routes are accessed using this JWT token for authentication.

As this is a demonstration project, the token generation endpoint is located on the same route as the others, and the login credentials are:

```
{
"username": "favorite_products_admin",
"password": "favorite_products_password"
}
```

Authentication is implemented, and the password is compared with its hash; the password itself is not hardcoded.
For the same reason of being a demonstrative project, the .env file is present in the repository to facilitate the use of the API.

After obtaining the token in the endpoint's response, the admin can access the SwaggerUI authorization window and authenticate with the JWT token, granting access to the other management endpoints.

The customer-related routes allow for adding, updating, deleting, and retrieving information for one or all registered clients. (The route to return all clients does not return the favorite lists of all registered clients as it is not good practice.)

The favorite products-related routes allow for adding a product to a customer's favorite list, deleting a product from the list, and retrieving a customer's favorite products list using their UUID.

The project has 3 tables, which are generated by the script included in the guide below.

The clients table stores the name and email of the customers and is indexed by their UUID.

The products_ref table serves as a reference table, storing the numeric ID of products that are part of at least one favorite list. This avoids duplicate data; otherwise, all product information would be stored multiple times for each customer who favorited it. When the data is needed, for example, to list favorites, a call is made to the FakeStoreAPI requesting the product corresponding to the ID. A cache was implemented so that this call is not made more often than necessary.

The client_favorite_products table is essentially the customers' favorite products list, linking the customer's UUID with the product's numeric ID.

## Performance and Scalability Choices
### Database Index Optimization

The table structure was designed to optimize data retrieval:

- All tables are indexed by their UUID or numeric IDs, respectively.
- The client_favorite_products table has the client's UUID as a Foreign Key (FK) to the clients table's UUID field. Both are part of a composite Primary Key (PK), benefiting from performance in searches and data validation. The same applies to the relationship with the products_ref table.
- The index on the clients table's email column allows for faster validation when dealing with duplicate emails. The same is true for the index on the name column.

### Cache Implementation

A cache was implemented to reduce the number of external calls to the FakeStoreAPI, increasing performance. The data is considered valid and stored for 1 hour and is used by the function that lists the products. If the product information is not in the cache, a call is made.
Asynchronous Processing

FastAPI allows requests to be asynchronous and does not block the processing of other requests while one is being processed.
SQLAlchemy and AsyncPG perform this same function at the database call level.
Requirements

- Python 3.8 or newer
- PostgreSQL

## How to Run the Project

- Clone the repository
- Create and activate a Python environment:

Assuming Windows in CMD:

python -m venv venv
venv\Scripts\activate

- Install the dependencies file:

pip install -r requirements.txt

- Through the PostgreSQL shell, psql:

Create the API user on the PostgreSQL server:
```
CREATE ROLE favorite_products_admin WITH LOGIN PASSWORD 'favorite_products_password';
```
Log in to PSQL with the new user:
```
\c fav_prd_db favorite_products_admin localhost 5432
favorite_products_password
```
Execute the script to create the database, tables, and relationships:
```
CREATE ROLE favorite_products_admin WITH LOGIN PASSWORD 'favorite_products_password';

CREATE DATABASE fav_prd_db
    OWNER = favorite_products_admin
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    TEMPLATE = template0;
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE IF NOT EXISTS products_ref (
    id INTEGER PRIMARY KEY
);

CREATE INDEX IF NOT EXISTS ix_products_ref_id ON products_ref (id);

CREATE TABLE IF NOT EXISTS clients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR NOT NULL,
    email VARCHAR UNIQUE NOT NULL
);

CREATE INDEX IF NOT EXISTS ix_clients_id ON clients (id);
CREATE INDEX IF NOT EXISTS ix_clients_name ON clients (name);
CREATE INDEX IF NOT EXISTS ix_clients_email ON clients (email);

CREATE TABLE IF NOT EXISTS client_favorite_products (
    client_id UUID NOT NULL,
    product_ref_id INTEGER NOT NULL,
    PRIMARY KEY (client_id, product_ref_id),
    CONSTRAINT fk_client FOREIGN KEY(client_id) REFERENCES clients(id) ON DELETE CASCADE,
    CONSTRAINT fk_product_ref FOREIGN KEY(product_ref_id) REFERENCES products_ref(id) ON DELETE CASCADE
);
```
If you have any connection problems, the database connection string is in the .env file.
```
DATABASE_URL = "postgresql+asyncpg://favorite_products_admin:favorite_products_password@localhost:5432/fav_prd_db"
```
- After the tables have been created in the database, we can run the API from the terminal:
```
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```
- The SwaggerUI will be available at http://127.0.0.1:8000/docs

## Explanation of Packages Used
``
fastapi
uvicorn[standard]
httpx
``

FastAPI is the main package of the application; it is responsible for handling the route structure, receiving requests, validating their responses, and generating the OpenAPI/Swagger documentation. Uvicorn is responsible for running FastAPI and has optimizations for handling HTTP requests. HTTPx is an HTTP client for communicating with the external FakeStore API.
``
sqlalchemy[asyncio]
asyncpg
psycopg2-binary
``

SQLAlchemy is a SQL toolkit and ORM that handles communication with the database. Aiming for scalability and performance, I used SQLAlchemy's asyncio and Asyncpg to handle database access asynchronously, preventing the API from having to wait for the database response without being able to process other requests.
``
passlib[bcrypt]
python-jose[cryptography]
``

Passlib was used to create the admin password hash and verify it at login. Python-JOSE is responsible for creating and validating the JWT.
``
cachetools
``

Cachetools was used to create a cache for requests made to the external FakeStoreAPI. Instead of making multiple calls to get data for the same product, the external API's response is saved internally and can be accessed by other requests to the API that need the same product. It is a TTLCache (Time To Live Cache), and it has a configurable time of 1 hour to keep the data. After this period, it will make the external request when that product is requested again.
``
pydantic-settings
email-validator
``

Pydantic is responsible for handling the API's schemas and models. It works with FastAPI, validating that all required request fields are filled and are of the expected type, respecting limits, and whether they are optional or not. Using the library's models makes it easier to handle data from the database, allowing them to be populated from ORM objects. It also handles serializing the API responses to JSON. Email-Validator is used to have the email type field in Pydantic models. The additional pydantic-settings library is used to read environment variables and settings from the .env file.
